Universal language: U = {(p, x) | p(x) does not halt}
    описывает поведение всех программ на всех входах
    consists of pairs {program, input}

    understandable, that p1, p2, p3 ... conforms to N
    градуированный лексикографический порядок

Universal language неразрешимый, но полуразрешимый\перечислимый

1) полуразрешитель: (p, x) => 
                              if p(x) == 1 
                                return 1 
                              else 
                                halt
2) неразрешимый? ну, предположим разрешимость. Пусть u(<p, x>) - разрешитель. 
    диагональный метод
      1,  2,  3,  ..  n                           u[p, x] - разрешитель
    p1X                                           Q(x)
                                                      return not u(x, x)
    p2    X                                             
                                                  Q(Q) = 0 => u(<Q, Q>) = 1 => Q(Q) = 1
    p3        X                                   Q(Q) = 1 => u(<Q, Q>) = 0 => Q(Q) = 0

    ..            X

    pn                X

    В частности, как бонус, дополнение U - это неперечислимый язык (если бы он был перечислимым, то сам U был бы разрешимым)
    Также забавно, что неперечислимых языков несчетное множество


Принцип любой последовательности программ // любого языка программирования
    1) существуют программы, которые зависают            
    2) существует разрешимый язык, для которого нет разрешителя среди p_i
    3) не существует универсального интерпретатора - (p, x) -> p(х) может быть невычислимой

Применим диагональный принцип
   К диагонали применим операцию без неподвижной точки. 
   1,  2,  3,  ..  n
 p1X                
                    
 p2    X            
                    
 p3        X        
                    
 ..            X    
                    
 pn                X

 Рассмотрим d(i) = p_i(x_i), но среди наших программ нет для нее разрешителя, т.к. отличается хотя бы 1 программа. 
 Но тогда наша функция невычислима. - ломается 3 критерий. 

Концепт сведения
    Введем два сведения - many-to-one и Тьюринг
    сведение по Тьюрингу сильнее, чем m-сведение. м-сведение делает что-то только со своим входом, 
    а у Тьюринга есть доступ к оракулу, которого нельзя создать функцией. // A to not A сводится по Тьюрингу, но не сводится m сведением. 

    m-сведение (mapping, many-to-one)
    Язык А, язык B - (два множества строк\чисел\программ) 
    A <=_m B, или A m-сводится к B (или просто сводится), когда существует вычислимая функция 
    на множестве всех строк f, которая x in A <==> f(x) in B  //  f(A) in B, f(not A) in not B
    Говорят, что А не сложнее B 


    Тогда если B разрешимый, то построим разрешитель А
        p(x):
            return (f(x) in B) 
    Если B полуразрешимый, то аналогично А тоже полуразрешимый. Программа 1 в 1 предыдущая. 
                
А как показать неразрешимость, или неполуразрешимость?
    Если А <=_m В, и А неразрешимый, то В тоже неразрешимый.
    Пусть А неразрешимый, а В разрешимый, тогда из предыдущего построим разрешитель для А и проиграем.
    С неполуразрешимостью точно так же.

Со сведением надо быть осторожным! Нельзя сводить не в ту сторону. Надо сводить сложное к простому, а не наоборот. 
То, что я проверку на четность свел к универсальному языку, не означает, что проверка на четность неразрешима. 
Утверждение - что если разрешимый B, значит, разрешимый и A.
А если есть A и B, А сведено к B, В неразрешимый - ну и что, как бы? Тут мы делаем вывод, что если А неразрешимый, то В тоже неразрешимый.
А не наоборот.


Свойство и теорема Успенского-Райса

RE - все перечислимые языки recursively enumerable, recursively по историческим причинам
Dec - все разрешимые языки decidable

Теорема Успенского-Райса говорит о том, что по программе ничего особо нельзя сказать. 
Формально - нельзя по программе сказать, принадлежит ли язык данному свойству или нет.

А - свойство = set in RE. Свойство никак не привязано к конкретной программе. 
Назовем свойство тривиальным, если оно либо пусто, либо равно RE
Языком свойства назовем все программы, чей язык лежит в этом свойстве \ обладает этим свойством
Осторожно! Язык обычно - это множество слов, а тут множество программ. 

Пример свойства - все конечные языки. Все языки, содержащие все простые числа. Все языки, допускающие 0.

Теорема Успенского-Райса о том, что язык свойства в общем случае неразрешим (по программе за конечное время не скажешь какой-то полезный и 
нетривиальный признак).

Ну полуразрешитель иногда можно построить. Для языкa программ, допускающих 0, можно написать полуразрешитель p(q): return q(0);
А вот про разрешимость можно сказать однозначно - только в двух случаях можно сказать о разрешимости однозначно (тривиальность)

ТЕОРЕМА УСПЕНСКОГО-РАЙСА
Если свойство нетривиально (не пустое и не RE), то L(A) неразрешим. 
// заметим, что А = {\emptyset} - нетривиально. Оно мощности один!

Доказательство от противного. 
    Пусть А - свойство, нетривиальное. Предположим, что L(A) разрешим. (это программы!) Р_А - разрешитель.
    Рассмотрим случай, когда \emptyset in A, (например, программа, которая всегда зацикливается, принадлежит L(A)).
    А также существует язык S != emptyset, not in A, but in RE. S полуразреш по опр => существует P_S. P_S not in L(A)

    Возьмем любой неразрешимый, но перечислимый язык Х. (например, универсальный)
    Существует полуразрешитель P_X.
    Напишем для Х разрешитель F_X(w).

    F_X(w): 
        // такое правило: w in X, L(p) = S and not in A
        // а если     w not in X, L(p) = \emptyset and in A
        tmp(x) = "
                  if P_X(w) == 1 
                    return P_S(x)
                  else
                    halt
                 " // построили программу, которая в зависимости от w или обладает языком S, или обладает языком \emptyset
        return !(P_A(p))

    // что получили? если w принадлежит неразрешимому языку, тогда вернется 1. Иначе вернется 0. 
    // Трассировку чуть упустил, но можно проделать аккуратнее. 
    // Написали разрешитель для неразрешимого языка.



Альтернативное доказательство от ~sta:
Рассмотрим свойство A. Его язык L. Свойство нетривиально, значит, есть какой-то язык слов R, q разрешитель
Предположим пока, что пустой язык не лежит в A

Сведем универсальный язык к языку L
    <p, x> : p(x) = 1 <===> <r> : r in L(A)

    r(w): "
          if p(x) = 1
            return q(w)
          else
            while true 
          "
          p(x) = 1 => r(w) = q(w) => L(r) == L(q) == R in L
          p(x)!= 1 => r(w) зависает, L(r) = \emptyset, \emptyset not in A
          m-сведение удалось
    Значит, наш язык неразрешим. 

Второй случай разбирается чуть иначе. Если пустой лежит в А, значит, А != RE, значит, существует язык R, не лежащий в L
Cведем L к дополнению R, там сработает сведение по Тьюрингу, значит p(x) = 1 ...=> R not in A
                                                                    p(x) = 0 ...=> R in A, значит, наш язык неразрешим, значит
                                                                    дополнение к нему неразрешимо. Профит.

А вот язык тривиальных свойств == пустое множество программ - действительно разрешим. 
Принадлежит ли моя программа этому множеству? Да нет, конечно))) return 0 да и все. (return 1 для A = RE)

    
Важное замечание, видимо, следующее. Про конкретно взятую программу можно что-то доказать. Важно то, что нельзя написать другую программу,
которая будет принимать текст других программ и про них что-то говорить.
